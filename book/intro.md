# Introduction

I wrote this book originally inspired by the idea of a comparitive languages book, comparing the approaches of multiple programming paradigms: functional, object oriented, imperative, logic (e.g. Prolog), and the like. What I wound up with, instead, was a collection of programming challenges I put together over a couple of years for the Reddit /r/dailyprogrammer community. 

I wrote each of these challenges in this book, although I certainly had inspiration from elsewhere in some cases. On the one hand I own the copyright for these challenges outright. On the other hand you wind up with a slightly narrow diversity in challenges. 

As you'll see, I tend to favor things like graph theory, number theory (especially the generation of integer sequences), and puzzles. One of the other moderators introduced me to computational geometry and so I later threw a few of those in there. Other moderators got me thinking about computer science and algorithm fundamentals, so there are some challenges in that vein but they're not all that common. I threw in some challenges with ciphers and encryption algorithms to help illustrate the history of the field and also how approachable encryption can be. 

But overall you'll find a bunch of challenges that remain variants on a theme: dynamic programming, constraint satisfaction, and such. 

## How to Use This Book

This book isn't meant to be read end to end, but instead picked from here and there. While challenges get harder through the book - progressing from easy to intermediate to hard - they don't follow a strict set of requirements for categorizing. Don't be discouraged, sometimes you can come back to a harder one after some thought and practice. 

A good thing to keep in mind is that you should your time to design a solution first, then implement it. As you progress you'll learn how to exploit the features of your language of choice and improve your coding. 

## A Note on Solutions

While working on this book, and through the Reddit community, I used these challenges to work on a few langages. As such, I wrote some code here and there to solve various challenges, although not all. Remember, I had originally planned a book comparing different programming paradigms. 

Solutions to some of these challenges appear peppered throughout the book. Here are some of the languages I used while coding and a brief bit about their style and such.

**Python** - a popular scripting language supporting object oriented and imperative paradigms. Python is a popular language for beginners and experts alike. I tend to write small prototypes in Python. Python has a lot of built-in features in many places. 

**FSharp** - a mixed paradigm language from Microsoft that runs on the DotNet runtime. It's essentially OCaml for DotNet, mixing imperative, objects, and functional programming paradigms. I tend to favor the functional programming aspects of the language. FSharp has become my go-to functional programming language. 

**Go** - an imperative language from Google, written in part by some of the original C and UNIX developers.

**Scala** - a mix-model programming language that runs on the JVM, mixing functional and object oriented aspects. While a lot of people tend to write more compact OOP in Scala, I tend to try and use it for functional programming aspects. 
